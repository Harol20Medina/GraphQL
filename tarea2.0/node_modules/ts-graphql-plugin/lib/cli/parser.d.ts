import { Logger } from './logger';
type BooleanOptionEntry = {
    alias?: string;
    description?: string;
    type: 'boolean';
};
type StringOptionEntry = {
    alias?: string;
    description?: string;
    defaultValue: string;
    type: 'string';
};
type OptionalStringOptionEntry = {
    alias?: string;
    description?: string;
    type: 'string';
};
type IntegerOptionEntry = {
    alias?: string;
    description?: string;
    defaultValue?: number;
    type: 'int';
};
type CommandLineOptionEntry = BooleanOptionEntry | StringOptionEntry | OptionalStringOptionEntry | IntegerOptionEntry;
type OptionsHolder = {
    options: {
        [name: string]: CommandLineOptionEntry;
    };
};
export type CommandCliSetting = OptionsHolder & {
    description: string;
};
type ParseOptions = {
    options: {
        [name: string]: CommandLineOptionEntry;
    };
    commands: {
        [name: string]: CommandCliSetting;
    };
    logger: Logger;
};
type Dispatch<T extends CommandLineOptionEntry> = T extends BooleanOptionEntry ? boolean : T extends StringOptionEntry ? string : T extends OptionalStringOptionEntry ? string | undefined : T extends IntegerOptionEntry ? number : never;
type OptionsResult<T extends OptionsHolder> = {
    [P in keyof T['options']]: Dispatch<T['options'][P]>;
};
export type CommandOptions<T extends CommandCliSetting> = {
    _: string[];
    options: OptionsResult<T>;
};
type ParseResult<T extends ParseOptions> = {
    _: string[];
    options: {
        [P in keyof T['options']]: Dispatch<T['options'][P]>;
    };
    command?: {
        [P in keyof T['commands']]?: CommandOptions<T['commands'][P]>;
    };
    errors?: {
        unknownCommand?: string;
    };
    availableCommandNames: () => string[];
    showHelp: () => void;
    showCommandHelp: (commandName: string) => void;
};
export declare function createParser<T extends ParseOptions>(parseOptions: T): {
    parse: (rawArguments?: string[]) => ParseResult<T>;
};
export {};
