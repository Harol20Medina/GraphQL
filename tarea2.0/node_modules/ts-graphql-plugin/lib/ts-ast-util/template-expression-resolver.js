"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateExpressionResolver = exports.createResultForNoSubstitution = void 0;
const typescript_1 = __importDefault(require("typescript"));
const string_util_1 = require("../string-util");
const utilily_functions_1 = require("./utilily-functions");
const last = (pos) => {
    throw new Error('invalid range: ' + pos);
};
function createResultForNoSubstitution(node, fileName) {
    const textLength = node.text.length;
    const start = node.end - textLength - (node.getText().endsWith('`') ? 1 /* , '`'.length , */ : 0);
    return {
        combinedText: node.text,
        getInnerPosition(pos) {
            if (pos < start) {
                throw new Error('invalid range: ' + pos);
            }
            else if (pos > start + textLength) {
                throw new Error('invalid range: ' + pos);
            }
            return { fileName, pos: pos - start };
        },
        getSourcePosition(pos) {
            if (pos < 0) {
                throw new Error('invalid range: ' + pos);
            }
            else if (pos > textLength) {
                throw new Error('invalid range: ' + pos);
            }
            return { fileName, pos: pos + start };
        },
        convertInnerLocation2InnerPosition: string_util_1.location2pos.bind(null, node.text),
        convertInnerPosition2InnerLocation: string_util_1.pos2location.bind(null, node.text),
    };
}
exports.createResultForNoSubstitution = createResultForNoSubstitution;
function createComputePositionsForTemplateHead(node, fileName) {
    const textLength = node.text.length;
    const start = node.end - textLength - (node.getText().endsWith('${') ? 2 /* , '${'.length , */ : 0);
    const getInnerPosition = (pos, next) => {
        if (pos < start) {
            throw new Error('invalid range: ' + pos);
        }
        else if (pos > start + textLength) {
            return next(pos);
        }
        return { fileName, pos: pos - start };
    };
    const getSourcePosition = (pos, next) => {
        if (pos < 0) {
            throw new Error('invalid range: ' + pos);
        }
        else if (pos > textLength) {
            return next(pos);
        }
        return { fileName, pos: pos + start };
    };
    return [getInnerPosition, getSourcePosition];
}
function createComputePositionsForTemplateSpan(node, fileName, headLength = 0) {
    const start = node.literal.pos + 1; /* , '}'.length , */
    const textLength = node.literal.text.length;
    const end = start + node.literal.text.length;
    const expressionStart = node.expression.pos;
    const getInnerPosition = (pos, next) => {
        if (pos < start) {
            throw new Error('invalid range: ' + pos);
        }
        else if (pos >= end) {
            return next(pos);
        }
        return { fileName, pos: pos - start + headLength };
    };
    const getSourcePosition = (pos, next) => {
        if (pos < headLength) {
            return { fileName, pos: expressionStart, isInOtherExpression: true };
        }
        else if (pos > headLength + textLength - (textLength ? 1 : 0)) {
            return next(pos);
        }
        return { fileName, pos: pos + start - headLength };
    };
    return [getInnerPosition, getSourcePosition];
}
class ResultCache {
    constructor(_maxSize = 200) {
        this._maxSize = _maxSize;
        this._cacheMap = new Map();
    }
    set(key, value) {
        this._cacheMap.set(key, value);
        if (this._cacheMap.size > this._maxSize) {
            const lru = this._cacheMap.keys().next();
            this._cacheMap.delete(lru.value);
        }
    }
    get(key) {
        const result = this._cacheMap.get(key);
        if (!result)
            return;
        return result;
    }
    has(key) {
        return this._cacheMap.has(key);
    }
    touch(key) {
        const result = this._cacheMap.get(key);
        if (!result)
            return;
        this._cacheMap.delete(key);
        this._cacheMap.set(key, result);
    }
    del(key) {
        this._cacheMap.delete(key);
    }
}
class TemplateExpressionResolver {
    constructor(_langService, _getFileVersion) {
        this._langService = _langService;
        this._getFileVersion = _getFileVersion;
        /** @internal **/
        this._resultCache = new ResultCache();
        /** @internal **/
        this._stringValueCache = new ResultCache();
        this.logger = () => { };
    }
    resolve(fileName, node) {
        const cacheValue = this._resultCache.get(node);
        if (cacheValue) {
            if (cacheValue.dependencyVersions.every(dep => this._getFileVersion(dep.fileName) === dep.version)) {
                this._resultCache.touch(node);
                this.logger('Use cache value: ' + cacheValue.result.combinedText);
                return { resolvedInfo: cacheValue.result, resolveErrors: [] };
            }
            else {
                this._resultCache.del(node);
            }
        }
        const setValueToCache = (resolvedInfo, dependencies = [fileName]) => {
            const versions = [...new Set(dependencies)].map(fileName => ({
                fileName,
                version: this._getFileVersion(fileName),
            }));
            this._resultCache.set(node, { result: resolvedInfo, dependencyVersions: versions });
            return {
                resolvedInfo,
                resolveErrors: [],
            };
        };
        if (typescript_1.default.isNoSubstitutionTemplateLiteral(node)) {
            return setValueToCache(createResultForNoSubstitution(node, fileName));
        }
        let template;
        if (typescript_1.default.isTemplateExpression(node)) {
            template = node;
        }
        else if (typescript_1.default.isTemplateExpression(node.template)) {
            template = node.template;
        }
        else if (typescript_1.default.isNoSubstitutionTemplateLiteral(node.template)) {
            return setValueToCache(createResultForNoSubstitution(node.template, fileName));
        }
        else {
            return {
                resolveErrors: [],
            };
        }
        const head = template.head;
        const [getInnerPosForHead, getSourcePosForHead] = createComputePositionsForTemplateHead(head, fileName);
        let headLength = head.text.length;
        let dependencies = [fileName];
        const texts = [head.text];
        const getInnerPositions = [getInnerPosForHead];
        const getSourcePositions = [getSourcePosForHead];
        const resolveErrors = [];
        for (const spanNode of template.templateSpans) {
            const { text: stringForSpan, dependencies: childDeps } = this._getValueAsString(fileName, spanNode.expression, dependencies);
            if (!stringForSpan) {
                resolveErrors.push({
                    fileName,
                    start: spanNode.expression.getStart(),
                    end: spanNode.expression.getEnd(),
                });
                continue;
            }
            headLength += stringForSpan.length;
            texts.push(stringForSpan);
            const [getInnerPositionsForSpan, getSourcePositionForSpan] = createComputePositionsForTemplateSpan(spanNode, fileName, headLength);
            getInnerPositions.unshift(getInnerPositionsForSpan);
            getSourcePositions.unshift(getSourcePositionForSpan);
            headLength += spanNode.literal.text.length;
            texts.push(spanNode.literal.text);
            dependencies = [...dependencies, ...childDeps];
        }
        if (resolveErrors.length > 0) {
            return {
                resolveErrors,
            };
        }
        const combinedText = texts.join('');
        return setValueToCache({
            combinedText,
            getInnerPosition: getInnerPositions.reduce((acc, fn) => (pos) => fn(pos, acc), last),
            getSourcePosition: getSourcePositions.reduce((acc, fn) => (pos) => fn(pos, acc), last),
            convertInnerLocation2InnerPosition: string_util_1.location2pos.bind(null, combinedText),
            convertInnerPosition2InnerLocation: string_util_1.pos2location.bind(null, combinedText),
        }, dependencies);
    }
    update(target, innerPositionRangeToChange, text = '') {
        const { combinedText: originalText, getInnerPosition: originalGetInnerPosition, getSourcePosition: originalGetSourcePosition, } = target;
        const headText = originalText.slice(0, innerPositionRangeToChange.start);
        const tailText = originalText.slice(innerPositionRangeToChange.end, originalText.length);
        const combinedText = headText + text + tailText;
        const getInnerPosition = (pos) => {
            const x = originalGetInnerPosition(pos);
            if (x.pos < innerPositionRangeToChange.start) {
                return x;
            }
            else if (innerPositionRangeToChange.start <= x.pos && x.pos < innerPositionRangeToChange.end) {
                return {
                    ...x,
                    pos: innerPositionRangeToChange.start,
                };
            }
            else {
                return {
                    ...x,
                    pos: x.pos - (innerPositionRangeToChange.end - innerPositionRangeToChange.start) + text.length,
                };
            }
        };
        const getSourcePosition = (pos) => {
            if (pos < innerPositionRangeToChange.start) {
                return originalGetSourcePosition(pos);
            }
            else if (innerPositionRangeToChange.start <= pos && pos < innerPositionRangeToChange.start + text.length) {
                return originalGetSourcePosition(innerPositionRangeToChange.start);
            }
            else {
                return originalGetSourcePosition(pos + (innerPositionRangeToChange.end - innerPositionRangeToChange.start) - text.length);
            }
        };
        return {
            combinedText,
            getInnerPosition,
            getSourcePosition,
            convertInnerLocation2InnerPosition: string_util_1.location2pos.bind(null, combinedText),
            convertInnerPosition2InnerLocation: string_util_1.pos2location.bind(null, combinedText),
        };
    }
    _getValueAsString(fileName, node, dependencies = [fileName]) {
        const cacheValue = this._stringValueCache.get(node);
        if (cacheValue) {
            if (cacheValue.dependencyVersions.every(dep => this._getFileVersion(dep.fileName) === dep.version)) {
                this._stringValueCache.touch(node);
                this.logger('Use cache value: ' + cacheValue.result);
                return { text: cacheValue.result, dependencies: cacheValue.dependencyVersions.map(dep => dep.fileName) };
            }
            else {
                this._stringValueCache.del(node);
            }
        }
        const setValueToCache = ({ text, dependencies }) => {
            this._stringValueCache.set(node, {
                result: text,
                dependencyVersions: [...new Set(dependencies)].map(fileName => ({
                    fileName,
                    version: this._getFileVersion(fileName),
                })),
            });
            return { text, dependencies };
        };
        const getValueForTemplateExpression = (node, dependencies) => {
            const texts = [node.head.text];
            let newDependenciees = [...dependencies];
            for (const span of node.templateSpans) {
                const { text: stringForSpan, dependencies: childDepes } = this._getValueAsString(fileName, span.expression, dependencies);
                if (!stringForSpan)
                    return { dependencies };
                texts.push(stringForSpan);
                texts.push(span.literal.text);
                newDependenciees = [...newDependenciees, ...childDepes];
            }
            return { text: texts.join(''), dependencies: newDependenciees };
        };
        if (typescript_1.default.isStringLiteral(node)) {
            return setValueToCache({ text: node.text, dependencies });
        }
        else if (typescript_1.default.isNoSubstitutionTemplateLiteral(node)) {
            return setValueToCache({ text: node.text, dependencies });
        }
        else if (typescript_1.default.isIdentifier(node)) {
            let currentFileName = fileName;
            let currentNode = node;
            while (true) {
                const defs = this._langService.getDefinitionAtPosition(currentFileName, currentNode.getStart());
                if (!defs || !defs[0])
                    return { dependencies };
                const def = defs[0];
                const src = this._langService.getProgram().getSourceFile(def.fileName);
                if (!src)
                    return { dependencies };
                const found = (0, utilily_functions_1.findNode)(src, def.textSpan.start);
                if (!found || !found.parent)
                    return { dependencies };
                currentFileName = def.fileName;
                if (typescript_1.default.isVariableDeclaration(found.parent) && found.parent.initializer) {
                    currentNode = found.parent.initializer;
                }
                else if (typescript_1.default.isPropertyDeclaration(found.parent) && found.parent.initializer) {
                    currentNode = found.parent.initializer;
                }
                else if (typescript_1.default.isPropertyAssignment(found.parent)) {
                    currentNode = found.parent.initializer;
                }
                else if (typescript_1.default.isShorthandPropertyAssignment(found.parent)) {
                    currentNode = found;
                }
                else {
                    return { dependencies };
                }
                if (typescript_1.default.isIdentifier(currentNode)) {
                    continue;
                }
                return setValueToCache(this._getValueAsString(currentFileName, currentNode, [...dependencies, currentFileName]));
            }
        }
        else if (typescript_1.default.isPropertyAccessExpression(node)) {
            return setValueToCache(this._getValueAsString(fileName, node.name, dependencies));
        }
        else if (typescript_1.default.isTaggedTemplateExpression(node)) {
            if (typescript_1.default.isNoSubstitutionTemplateLiteral(node.template)) {
                return setValueToCache({ text: node.template.text, dependencies });
            }
            else {
                return setValueToCache(getValueForTemplateExpression(node.template, dependencies));
            }
        }
        else if (typescript_1.default.isTemplateExpression(node)) {
            return setValueToCache(getValueForTemplateExpression(node, dependencies));
        }
        return { dependencies };
    }
}
exports.TemplateExpressionResolver = TemplateExpressionResolver;
//# sourceMappingURL=template-expression-resolver.js.map